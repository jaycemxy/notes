## HTML部分
1. 如何理解html语义化
  
  一开始写html的是后端程序员，他们不会CSS，于是用table来布局，但table是展示表格用的，严重违反了html语义化；后来有了专门写CSS的前端程序员，他们会使用div+CSS来布局页面，主要用float的绝对定位来布局，这稍微符合了一点语义化；再后来，前端专业化，知道了HTML各个部分的用法，于是就可以用恰当的标签来展示相应内容，而不是一见到一块内容就用div，尽量使用p标签表示段落、main表示主要内容、页边栏用aside、标题用h1、h2等。

2. meta viewport做什么用的？
  
  控制页面在移动端不要缩放，简敲meta:vp
  ```
  <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
  ```
  一开始所有页面都是为PC端准备的，乔布斯推出了iPhone3GS，页面是不适应手机屏幕的，所以苹果工程师想出了一个办法，默认手机模拟成980px，从而将页面缩小；后来智能手机普及，这个功能部分网站不需要，所以用meta:vp让手机不要缩小网页。

3. Canvas元素 参考canvas-demo项目
## CSS部分
1. 盒模型

  分为content-box和border-box，content-box的宽度为内容区宽度，border-box宽度为内容区宽度+padding宽度

  举例说，页面中有一个div，给div一个宽度100px，一个padding为20px，那么这个div所占宽度就是100px加上两个20px的padding

2. CSS reset和normalize CSS的区别
 
   - reset是重置，抛弃了默认样式，之前的样式我都不要
   - normalize让浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一
3. 如何居中

  - 水平居中

    内联元素：爸爸身上写text-align:center;
  
    块级元素：margin-right: auto; margin-left: auto;
  - 垂直居中(demo详见demos文件)
    
    a、table自带功能

    b、div装成table

    c、translate: (-50%，-50%);

    d、margin:auto;

    e、flex
4. 选择器优先级如何确定？
   - 选择器越具体，优先级越高
   - 同样优先级，写在后面的覆盖写在前面的
   - color:red; !important优先级最高，但是不要轻易使用important
5. BFC是什么？

   - overflow:hidden; 清除浮动（但是建议用.clearfix）
   -  overflow:hidden; 取消父子margin合并（建议用padding-top:0.1px;）
6. 如何清除浮动
  - overflow:hidden;（不建议用）
  - .clearfix写在爸爸身上
```
    .clearfix{
        content:'';
        display: block;
        clear: both;
        zoom : 1;   /*兼容IE的*/
    }
```
## JS部分
1. 如何使用promise
- then的链式用法
```
$.ajax(...).then(successFn,errorFn).then(successFn2,errorFn2)
```
- 自己生成promise对象
```
function xxx(){
  return new Promise(function(resolve,reject){  //关键句
    setTimeout(()=>{
      resolve()  //成功就调
      reject()  //失败就调
    }, 5000)
  })
}

xxx.().then(value)
console.log(value);
```
- await的用法
```
function xxx(){
  return new Promise(function(resolve,reject){  //关键句
    setTimeout(()=>{
      resolve()  //成功就调
      reject()  //失败就调
    }, 5000)
  })
}

var promise = await xxx()  //await左边是同步的，右边是异步的，由await隔开，有了await它会等待异步的结果，从而改变整个代码的执行顺序，await后接一个返回promise的函数
```
- try...catch捕获报错信息

catch是一个没有成功函数的失败函数，相当于then的语法糖
```
function xxx(){
  return new Promise(function(resolve,reject){  //关键句
    setTimeout(()=>{
      resolve()  //成功就调
      reject()  //失败就调
    }, 5000)
  })
}

try{
  var promise = await xxx()
  console.log('没出错')
}catch(error){
  console.log('异常了')
}
```

2. 原生JS写ajax请求
```
let xhr = new XMLHttpRequest()
xhr.open('GET', url)
xhr.onreadystatechange = function(){
  if(xhr.readystate === 4){
    if(xhr.status >= 200 && xhr.status < 300){
      console.log('说明请求成功')
    }else if(xhr.status >= 400){
      console.log('说明请求失败')
    }
  }
}
xhr.send()
```
3. 闭包是什么
- 定义

首先声明一个立即执行函数，这个函数里有一个变量和一个函数
```
!function(){
  var n = 0
  function createAdder(){
    return n += 1
  }
}()

let adder = createAdder()
adder()  //n === 1
adder()  //n === 2
console.log(n)  //n is not defined
```
在这个立即执行函数里，createAdder函数内部用到了它作用域外的变量n，这个函数和这个变量所在环境就形成了一个闭包

- 作用

间接访问一个变量，也可以说是对外隐藏了一个变量

4. 一段代码里的this是什么？（call一个函数时，给这个函数传入的第一个参数就是this）
- fn()里面的this是window
- fn()是strict mode时，this就是undefined
- a.b.c.fn()中this就是a.b.c即fn前面的东西
- () => console.log(this)，里面的this就是外面的this，外面的this用前三条可以确定

5. 立即执行函数
- 定义
  声明一个匿名函数，并且马上调用这个匿名函数
- 形式
```
!function(){
  ...
}()

(function(){
  ...
}())

~function(){

}
```
- 作用
  创建一个独立作用域，这个作用域内的变量外部访问不到，避免全局污染

6. async/await语法是什么？目的是？
```
function returnPromise(){
  return new Promise(function(resolve,reject){
    setTimeout(() => {
      resolve('成功')
    }, 3000)
  })
}

returnPromise().then((result)=>{  //将异步代码
  result === '成功'
})

var result = await returnPromise()  //写成同步
return === '成功'
```
作用：模拟同步代码，即用同步的形式来写异步的代码，这样就不用回调了

7. 如何实现深拷贝
- JSON实现方式
```
var a = {...}
var b = JSON.parse(JSON.stringify(a))
```
将这个对象变成一个字符串，再从字符串里生成一个对象

缺点是JSON不支持函数、引用、undefined、RegExp正则、Date ...
- 递归拷贝（要有clone，并且需要考虑他是Array、Function还是Object）
```
function clone(object){
  var object2
  if(!(object instanceof Object)){
    return object
  }else if(object instanceof Array){
    object2[]
  }else if(object instanceof Function){
    object2 = eval(object.toString())
  }else if(object instanceof Object){
    object2 = {}
  }
  for(let key in object){
    object2[key] = clone(object[key])
  }
  return object2
}
```
8. 如何实现数组去重
- 基数排序的逻辑（只能是正整数）
```
var a = [4,2,5,6,3,4,5]
var hashTab = {}
for(let i=0; i<a.length; i++){
  if(a[i] in hashTab){
    //什么都不做
  }else{
    hashTab[a[i]] = true
  }
}
//hashTab:{4:true, 2:true, 5:true, 6:true, 3:true}
console.log(Object.keys(hashTab))  //['4','2','5','6','3'] 得到的是字符串，想要得到数组用map去遍历
```
- 用Set去重
```
a = [1,3,4,1,3,3,2,1]
Array.from(new Set(a))
-> a = [1,3,4,2]
```
9. 如何用正则实现string.trim()
```
function trim(string){
  return string.trim.replace(/^\s+|\s+$/,'') 
}
```
10. JS原型是什么？
举例说，
- var a = [1,2,3]
- 变量a只有0，1，2，length这4个key
- 但是可以a.push(4)
- 因为a.__proto__ === Array.prototype
- push方法就是沿着a.__proto__找到的，也就是Array.prototype.push
- Array.prototype还有很多方法，例如pop、join、slice、splice等
11. ES6中的class了解吗？
举例说明
```
class Animal {
  constructor(){  //构造自有属性
    this.body = '身体'
  }
  move(){
    console.log('动两下')
  }
}

class Person extends Animal {
  constructor(name){
    super()  //相当于拥有了 this.body = '身体' 这个属性
    this.name = name
  }
  useTools(){}
} 

var p1 = new Person('jayce')
```
12. 如何实现继承？(使用ES6中 extends 关键字)
## DOM部分
1. DOM事件模型
- 冒泡
- 捕获
- 如果这个元素是被点击元素，那么捕获不一定在冒泡之前，顺序是由监听顺序决定的
2. 移动端的触摸事件
- touchstart touchend touchmove touchcancel
- 模拟swipe事件，记录两次touchmove的位置差，如果最后一次在前一次的右边，那么说明向右滑了 
3. 事件委托是什么，好处是？
- 假设父元素有四个儿子，我不去监听四个儿子而是监听父元素，看触发事件的元素是哪个儿子
- 可以监听还没有定义的儿子（动态生成的元素），节省监听器
举例：
```
function listen(element,eventType,selector,fn){
  element.addEventListener (eventType,e => {
    if(e.target.matches(selector)){
      fn.call(el, e.el)
    }
  })
}
```
## HTTP部分
1. http状态码
- 200 OK 请求成功
- 301 Moved Permanently 永久重定向，浏览器会记住
- 302 Moved Temporarily 临时重定向，浏览器不会记住
- 401 Unauthorized 请求未经授权
- 403 Forbidden 服务器已经理解请求，但是拒绝执行它
- 404 Not Found 请求失败，请求的资源未被在服务器上发现
- 500 Internal Server Error 服务器发生不可预期的错误
- 503 Server Unavailable 服务器当前不能处理客户端请求，一段时间后可能恢复正常
2. HTTP缓存怎么做？
- Cache-Control：max-age = 300
- http://cdn.com/1.js?v=1 避开缓存
3. cookie和session是什么？
- cookie：HTTP响应通过set-cookie设置cookie；浏览器访问指定域名时必须加上cookie作为Request Header请求头；cookie一般用来记录用户信息
- session：是服务器端的内存；一般通过在cookie里记录SessionID实现；SessionID一般是随机数
4. Localstorage和cookie的区别
- cookie会随着请求被发到服务器上，而Localstorage不会
- cookie的大小一般在4k一下，而Localstorage一般在5MB左右
5. GET和POST的区别？
- 参数。GET参数放在url的查询参数里并且有长度限制（一般是1024个字符），POST的数据放在请求消息体里没有限制（4-10MB限制）
- 安全。GET相对来说没有POST安全（两个都不怎么安全）
- 包。GET请求只需发一个包，POST请求需要发两个以上包（因为POST有消息体）
- GET用来读数据，POST用来写数据并且POST不幂等（幂等：不管发多少次请求结果都一样）
6. 如何跨域？（JSONP、CORS以及postMessage）
- JSONP

网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。简单来说就是script标签加一个callback的回调函数
- CORS

CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写，它是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。

简单来说就是服务端在响应头中添加一个Access-Control-Allow-Origin 的头部，头部的值为客户端的域名，eg：
```
  response.setHeader('Access-Control-Allow-Origin','http://jayce.com:8003')
```
- postMessage
语法：otherWindow.postMessage(message, targetOrigin);

i. otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 
window.open 方法创建的窗口

ii. message: 是要发送的消息，类型为 String、Object

iii. targetOrigin: 是限定消息接收范围，可以是*（无限制）或者一个URL

举例父窗口http://aaa.com向子窗口http://bbb.com发送消息
```
var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
```
子窗口向父窗口发送消息也是类似
```
window.opener.postMessage('Nice to see you', 'http://aaa.com');
```